"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const PseudoRandom_1 = require("../src/crypter/PseudoRandom");
const BytesToBitIterator_1 = require("../src/crypter/BytesToBitIterator");
const utils_1 = require("../src/crypter/utils");
const RandomBitIterator_1 = require("../src/crypter/RandomBitIterator");
const CombineIterator_1 = require("../src/crypter/CombineIterator");
const Crypter_1 = require("../src/crypter/Crypter");
const FixedLength_1 = require("../src/crypter/FixedLength");
const crypterTestData = __importStar(require("./dataset/crypterTestData.json"));
describe('Crypter', () => {
    describe('PseudoRandom', () => {
        it('random byte', () => {
            const pseudoRandom = new PseudoRandom_1.PseudoRandom(Uint8Array.from([0x1e, 0x33, 0x43, 0xe0, 0x25, 0x3a, 0xb5, 0xa0, 0xf9, 0x0d, 0x33, 0x95, 0x10, 0xaa, 0x7d, 0xee]));
            const expectedBytes = [223, 151, 156, 50, 123, 196, 29, 177, 74, 148, 156, 220, 244, 146, 22, 131, 21, 111, 117, 65, 23, 89, 254, 68, 206, 148, 185, 154, 156, 29, 165, 91];
            for (const expectedByte of expectedBytes)
                (0, chai_1.expect)(pseudoRandom.randomByte()).to.be.equal(expectedByte);
        });
    });
    describe('utils', () => {
        it('bits', () => {
            const dataset = [
                [0x00, [0, 0, 0, 0, 0, 0, 0, 0]],
                [0x01, [0, 0, 0, 0, 0, 0, 0, 1]],
                [0x4e, [0, 1, 0, 0, 1, 1, 1, 0]],
                [0xff, [1, 1, 1, 1, 1, 1, 1, 1]]
            ];
            for (const data of dataset)
                (0, chai_1.expect)((0, utils_1.bits)(data[0])).to.be.deep.equal(data[1]);
        });
        it('invalid bits', () => {
            try {
                (0, utils_1.bits)(0x111);
                chai_1.expect.fail('Expect error thrown');
            }
            catch (error) {
                (0, chai_1.expect)(error).to.have.ownProperty('message');
                (0, chai_1.expect)(error.message).to.be.equal('Value isn\'t a valid byte.');
            }
        });
        it('xor', () => {
            (0, chai_1.expect)((0, utils_1.xor)(0, 0)).to.be.equal(0);
            (0, chai_1.expect)((0, utils_1.xor)(1, 1)).to.be.equal(0);
            (0, chai_1.expect)((0, utils_1.xor)(0, 1)).to.be.equal(1);
            (0, chai_1.expect)((0, utils_1.xor)(1, 0)).to.be.equal(1);
        });
        it('bitIteratorToBuffer 1', () => {
            const bitIterator = [][Symbol.iterator]();
            const buffer = (0, utils_1.bitIteratorToBytes)(bitIterator);
            const expectedBuffer = Uint8Array.from([]);
            (0, chai_1.expect)(buffer).to.be.deep.equal(expectedBuffer);
        });
        it('bitIteratorToBuffer 2', () => {
            const bitIterator = [0, 0, 1, 0, 0, 0, 1, 1][Symbol.iterator]();
            const buffer = (0, utils_1.bitIteratorToBytes)(bitIterator);
            const expectedBuffer = Uint8Array.from([0x23]);
            (0, chai_1.expect)(buffer).to.be.deep.equal(expectedBuffer);
        });
        it('bitIteratorToBuffer 3', () => {
            const bitIterator = [
                0, 0, 1, 0, 0, 0, 1, 1,
                0, 1, 0, 0, 0, 1, 0, 1,
                0, 1, 1, 0, 0, 1, 1, 1,
                1, 0, 1, 0, 1, 1, 1, 1
            ][Symbol.iterator]();
            const buffer = (0, utils_1.bitIteratorToBytes)(bitIterator);
            const expectedBuffer = Uint8Array.from([0x23, 0x45, 0x67, 0xaf]);
            (0, chai_1.expect)(buffer).to.be.deep.equal(expectedBuffer);
        });
    });
    describe('BufferToBitIterator', () => {
        it('buffer to bits 1', () => {
            const buffer = Uint8Array.from([]);
            const bufferToBitIterator = new BytesToBitIterator_1.BytesToBitIterator(buffer);
            const expectedBits = [];
            let bitResult = bufferToBitIterator.next();
            let index = 0;
            while (!(bitResult.done ?? false)) {
                (0, chai_1.expect)(bitResult.value).to.be.equal(expectedBits[index]);
                bitResult = bufferToBitIterator.next();
                index += 1;
            }
        });
        it('buffer to bits 2', () => {
            const buffer = Uint8Array.from([0x23]);
            const bufferToBitIterator = new BytesToBitIterator_1.BytesToBitIterator(buffer);
            const expectedBits = [0, 0, 1, 0, 0, 0, 1, 1];
            let bitResult = bufferToBitIterator.next();
            let index = 0;
            while (!(bitResult.done ?? false)) {
                (0, chai_1.expect)(bitResult.value).to.be.equal(expectedBits[index]);
                bitResult = bufferToBitIterator.next();
                index += 1;
            }
        });
        it('buffer to bits 3', () => {
            const buffer = Uint8Array.from([0x23, 0x45, 0x67, 0xaf]);
            const bufferToBitIterator = new BytesToBitIterator_1.BytesToBitIterator(buffer);
            const expectedBits = [
                0, 0, 1, 0, 0, 0, 1, 1,
                0, 1, 0, 0, 0, 1, 0, 1,
                0, 1, 1, 0, 0, 1, 1, 1,
                1, 0, 1, 0, 1, 1, 1, 1
            ];
            let bitResult = bufferToBitIterator.next();
            let index = 0;
            while (!(bitResult.done ?? false)) {
                (0, chai_1.expect)(bitResult.value).to.be.equal(expectedBits[index]);
                bitResult = bufferToBitIterator.next();
                index += 1;
            }
        });
    });
    describe('RandomBitIterator', () => {
        it('random bits', () => {
            const randomBitIterator = new RandomBitIterator_1.RandomBitIterator(Uint8Array.from([0x1e, 0x33, 0x43, 0xe0, 0x25, 0x3a, 0xb5, 0xa0, 0xf9, 0x0d, 0x33, 0x95, 0x10, 0xaa, 0x7d, 0xee]));
            const expectedBits = [
                1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0,
                0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1
            ];
            for (const expectedBit of expectedBits)
                (0, chai_1.expect)(randomBitIterator.next().value).to.be.equal(expectedBit);
        });
    });
    describe('CombineIterator', () => {
        it('combine 1', () => {
            const iterator1 = [1, 2, 3][Symbol.iterator]();
            const iterator2 = [4, 5, 6][Symbol.iterator]();
            const combineIterator = new CombineIterator_1.CombineIterator(iterator1, iterator2, (e1, e2) => [e1, e2]);
            const expectedData = [[1, 4], [2, 5], [3, 6]];
            for (const expected of expectedData)
                (0, chai_1.expect)(combineIterator.next().value).to.be.deep.equal(expected);
        });
        it('combine 1', () => {
            const iterator1 = [1, 2][Symbol.iterator]();
            const iterator2 = [4, 5, 6][Symbol.iterator]();
            const combineIterator = new CombineIterator_1.CombineIterator(iterator1, iterator2, (e1, e2) => [e1, e2]);
            const expectedData = [[1, 4], [2, 5]];
            for (const expected of expectedData)
                (0, chai_1.expect)(combineIterator.next().value).to.be.deep.equal(expected);
        });
        it('combine 1', () => {
            const iterator1 = [1, 2, 3][Symbol.iterator]();
            const iterator2 = [4, 5][Symbol.iterator]();
            const combineIterator = new CombineIterator_1.CombineIterator(iterator1, iterator2, (e1, e2) => [e1, e2]);
            const expectedData = [[1, 4], [2, 5]];
            for (const expected of expectedData)
                (0, chai_1.expect)(combineIterator.next().value).to.be.deep.equal(expected);
        });
    });
    describe('Crypter', () => {
        const cryptionKeys = {
            encryptionKey: new FixedLength_1.FixedLength(Uint8Array.from([0x37, 0xe6, 0x91, 0x57, 0xda, 0xc0, 0x1c, 0x0a, 0x9c, 0x93, 0xea, 0x1c, 0x72, 0x10, 0x41, 0xe6, 0x26, 0x86, 0x94, 0x3f, 0xda, 0x9d, 0xab, 0x30, 0xf7, 0x56, 0x5e, 0xdb, 0x3e, 0xf1, 0x5f, 0x5b]), 32),
            initialisationVector: new FixedLength_1.FixedLength(Uint8Array.from([0x69, 0x29, 0xd3, 0xdc, 0x8d, 0xd4, 0x1c, 0x90, 0x81, 0x2e, 0x30, 0x2a, 0x4b, 0x01, 0x03, 0x78]), 16),
            vernamKey: new FixedLength_1.FixedLength(Uint8Array.from([0x9f, 0x10, 0x2b, 0x4b, 0x5f, 0x0b, 0x5c, 0x50, 0x82, 0xd2, 0xa7, 0xbb, 0x7c, 0x7f, 0x13, 0x9f, 0xed, 0x6a, 0x99, 0x5e, 0xcf, 0x1f, 0x28, 0x80, 0x94, 0x20, 0x3c, 0xc3, 0x92, 0xf9, 0x6b, 0x5e]), 32)
        };
        const crypter = new Crypter_1.Crypter(cryptionKeys);
        it('aes encrypt', () => {
            const originalBytes = Uint8Array.from(crypterTestData.aesOriginal);
            const encryptedBytes = crypter.encryptAes(originalBytes);
            const expectedEncryptedBytes = Uint8Array.from(crypterTestData.aesEncrypted);
            (0, chai_1.expect)(encryptedBytes).to.be.deep.equal(expectedEncryptedBytes);
        });
        it('aes decrypt', () => {
            const encryptedBytes = Uint8Array.from(crypterTestData.aesEncrypted);
            const originalBytes = crypter.decryptAes(encryptedBytes);
            const expectedOriginalBytes = Uint8Array.from(crypterTestData.aesOriginal);
            (0, chai_1.expect)(originalBytes).to.be.deep.equal(expectedOriginalBytes);
        });
        it('aes encrypt and decrypt', () => {
            const originalBytes = Uint8Array.from(crypterTestData.aesOriginal);
            const encryptedBytes = crypter.encryptAes(originalBytes);
            const decryptedBytes = crypter.decryptAes(encryptedBytes);
            (0, chai_1.expect)(decryptedBytes).to.be.deep.equal(originalBytes);
        });
        it('vernam decrypt', () => {
            const encryptedBytes = Uint8Array.from(crypterTestData.vernamEncrypted);
            const originalBytes = crypter.decryptVernamCipher(encryptedBytes);
            const expectedOriginalBytes = Uint8Array.from(crypterTestData.vernamOriginal);
            (0, chai_1.expect)(originalBytes).to.be.deep.equal(expectedOriginalBytes);
        });
        it('vernam encrypt and decrypt', () => {
            const originalBytes = Uint8Array.from(crypterTestData.vernamOriginal);
            const encryptedBytes = crypter.encryptVernamCipher(originalBytes);
            const decryptedBytes = crypter.decryptVernamCipher(encryptedBytes);
            (0, chai_1.expect)(decryptedBytes).to.be.deep.equal(originalBytes);
        });
        it('aes vernam decrypt', () => {
            const encryptedBytes = Uint8Array.from(crypterTestData.aesVernamEncrypted);
            const originalBytes = crypter.decryptAesAndVernam(encryptedBytes);
            const expectedOriginalBytes = Uint8Array.from(crypterTestData.aesVernamOriginal);
            (0, chai_1.expect)(originalBytes).to.be.deep.equal(expectedOriginalBytes);
        });
        it('aes vernam encrypt and decrypt', () => {
            const originalBytes = Uint8Array.from(crypterTestData.aesVernamOriginal);
            const encryptedBytes = crypter.encryptVernamAndAes(originalBytes);
            const decryptedBytes = crypter.decryptAesAndVernam(encryptedBytes);
            (0, chai_1.expect)(decryptedBytes).to.be.deep.equal(originalBytes);
        });
        it('decrypt decode', () => {
            const encrypted = (0, utils_1.unishortString)(Uint8Array.from(crypterTestData.encodedEncrypted));
            const decrypted = crypter.decryptDecode(encrypted);
            (0, chai_1.expect)(decrypted).to.be.equal(crypterTestData.decryptedDecoded);
        });
        it('decrypt decode and encode encrypt', () => {
            const encrypted = crypter.encodeEncrypt(crypterTestData.decryptedDecoded);
            const decrypted = crypter.decryptDecode(encrypted);
            (0, chai_1.expect)(decrypted).to.be.equal(crypterTestData.decryptedDecoded);
        });
        it('decrypt decode emtpy string', () => {
            (0, chai_1.expect)(crypter.decryptDecode('')).to.be.undefined;
        });
    });
    describe('FixedLength', () => {
        it('length 16 valid', () => {
            (0, chai_1.expect)(new FixedLength_1.FixedLength('abcdefghijklmnop', 16).value).to.be.equal('abcdefghijklmnop');
        });
        it('length 16 not length 16', () => {
            try {
                // eslint-disable-next-line no-new
                new FixedLength_1.FixedLength('a', 16);
            }
            catch (error) {
                (0, chai_1.expect)(error).to.have.ownProperty('message');
                (0, chai_1.expect)(error.message).to.be.equal('Expected value to has length 16.');
                return;
            }
            chai_1.expect.fail('Expect throw');
        });
    });
    it('padding', () => {
        for (let i = 0; i < 16; i++) {
            const original = new Uint8Array(32 + i);
            const withPadding = (0, utils_1.addPadding)(original);
            (0, chai_1.expect)(withPadding.length % 16).to.be.deep.equal(0);
            const withoutPadding = (0, utils_1.removePadding)(withPadding);
            (0, chai_1.expect)(withoutPadding).to.be.deep.equal(original);
        }
    });
    it('hash', () => {
        (0, chai_1.expect)(Crypter_1.Crypter.sha512('lkjdasflnc')).to.be.equal('rbswGhojGpzw7EoB61dz3LpecUiFV7y0QHhO7xLHbgtPHhjsKxH6nbUg2p6B5CpSAa1hMzJKBfM8twldRbKj1g');
        (0, chai_1.expect)(Crypter_1.Crypter.sha512('lkjdasflnc', 'oimli')).to.be.equal('5NRfmNX8NnSCP2jrQIrhmkpo+wpz27FQDyU4_4lheOiJ8etSQ+spWak39WgaF8lzd8qwHzlkrfixZIZlf_1hSQ');
    });
});
