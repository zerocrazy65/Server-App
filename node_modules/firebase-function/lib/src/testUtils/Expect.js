"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExpectResult = exports.ExpectToBeDeep = exports.ExpectToBe = exports.ExpectTo = exports.Expect = exports.expectHttpsError = exports.expectResult = exports.expect = void 0;
const chai_1 = require("chai");
function expect(value) {
    return new Expect(value);
}
exports.expect = expect;
function expectResult(result) {
    return new ExpectResult(result);
}
exports.expectResult = expectResult;
function expectHttpsError(execute, code) {
    try {
        execute();
        chai_1.expect.fail('Expected to throw an error.');
    }
    catch (error) {
        (0, chai_1.expect)(error).to.have.ownProperty('httpErrorCode');
        (0, chai_1.expect)(error).to.have.ownProperty('code');
        (0, chai_1.assert)(typeof error === 'object' && error !== null && 'code' in error);
        (0, chai_1.expect)(error.code).to.be.equal(code);
    }
}
exports.expectHttpsError = expectHttpsError;
class Expect {
    _value;
    constructor(_value) {
        this._value = _value;
    }
    value(key) {
        return new Expect(this._value[key]);
    }
    get to() {
        return new ExpectTo(this._value);
    }
}
exports.Expect = Expect;
class ExpectTo {
    _value;
    constructor(_value) {
        this._value = _value;
    }
    get be() {
        return new ExpectToBe(this._value);
    }
}
exports.ExpectTo = ExpectTo;
class ExpectToBe {
    _value;
    constructor(_value) {
        this._value = _value;
    }
    get deep() {
        return new ExpectToBeDeep(this._value);
    }
    equal(value, message) {
        return (0, chai_1.expect)(this._value).to.be.equal(value, message);
    }
    unsorted(value, message) {
        chai_1.assert.fail('Use deep unsorted array.');
    }
}
exports.ExpectToBe = ExpectToBe;
class ExpectToBeDeep {
    _value;
    constructor(_value) {
        this._value = _value;
    }
    equal(value, message) {
        return (0, chai_1.expect)(this._value).to.be.deep.equal(value, message);
    }
    unsorted(value, message) {
        (0, chai_1.assert)(Array.isArray(this._value));
        (0, chai_1.expect)(this._value.length).to.be.equal(value.length);
        for (const element of value) {
            // eslint-disable-next-line eqeqeq
            const index = this._value.findIndex(e => this.deepEqual(e, element));
            if (index === -1)
                chai_1.assert.fail(message ?? `Couldn't find element: ${JSON.stringify(element)}`);
            this._value.splice(index, 1);
        }
    }
    deepEqual(value1, value2) {
        if (typeof value1 !== 'object' || value1 === null || typeof value2 !== 'object' || value2 === null)
            return value1 === value2;
        if (Array.isArray(value1) || Array.isArray(value2)) {
            if (!Array.isArray(value1) || !Array.isArray(value2))
                return false;
            if (value1.length !== value2.length)
                return false;
            for (let i = 0; i < value1.length; i++) {
                if (!this.deepEqual(value1[i], value2[i]))
                    return false;
            }
            return true;
        }
        const _value1 = this.removeUndefined(value1);
        const _value2 = this.removeUndefined(value2);
        if (Object.keys(_value1).length !== Object.keys(_value2).length)
            return false;
        for (const key of Object.keys(_value1)) {
            if (!(key in _value2))
                return false;
            if (!this.deepEqual(_value1[key], _value2[key]))
                return false;
        }
        return true;
    }
    removeUndefined(value) {
        const v = {};
        for (const key of Object.keys(value)) {
            if (value[key] !== undefined)
                v[key] = value[key];
        }
        return v;
    }
}
exports.ExpectToBeDeep = ExpectToBeDeep;
class ExpectResult {
    result;
    constructor(result) {
        this.result = result;
    }
    get success() {
        if (this.result.state === 'failure') {
            console.error(this.result.error.code, this.result.error.message);
            console.error(this.result.error);
        }
        expect(this.result.state).to.be.equal('success');
        (0, chai_1.assert)(this.result.state === 'success');
        return typeof this.result.value === 'object' ? new ExpectToBeDeep(this.result.value) : new ExpectToBe(this.result.value);
    }
    get failure() {
        expect(this.result.state).to.be.equal('failure');
        (0, chai_1.assert)(this.result.state === 'failure');
        return new ExpectToBeDeep({
            code: this.result.error.code,
            message: this.result.error.message
        });
    }
}
exports.ExpectResult = ExpectResult;
