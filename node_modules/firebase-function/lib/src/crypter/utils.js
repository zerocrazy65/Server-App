"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removePadding = exports.addPadding = exports.unishortBytes = exports.unishortString = exports.randomBytes = exports.bitIteratorToBytes = exports.xor = exports.bits = void 0;
const crypto_1 = require("crypto");
function bits(byte) {
    const totalBitsCount = 8;
    const bitsArray = Array(totalBitsCount).fill(0);
    for (let index = 0; index < totalBitsCount; index++) {
        const bit = byte % 0x02;
        byte = (byte - bit) / 0x02;
        bitsArray[totalBitsCount - index - 1] = bit === 0 ? 0 : 1;
    }
    if (byte !== 0)
        throw new Error('Value isn\'t a valid byte.');
    return bitsArray;
}
exports.bits = bits;
function xor(bit1, bit2) {
    return bit1 === bit2 ? 0 : 1;
}
exports.xor = xor;
function bitIteratorToBytes(iterator) {
    const bytes = [];
    let currentByte = 0;
    let index = 0;
    let iteratorResult = iterator.next();
    while (!(iteratorResult.done ?? false)) {
        currentByte += iteratorResult.value * (1 << (7 - index));
        iteratorResult = iterator.next();
        index += 1;
        if (index === 8) {
            bytes.push(currentByte);
            currentByte = 0;
            index = 0;
        }
    }
    return Uint8Array.from(bytes);
}
exports.bitIteratorToBytes = bitIteratorToBytes;
function randomBytes(length) {
    const bytes = new Uint8Array(length);
    crypto_1.webcrypto.getRandomValues(bytes);
    return bytes;
}
exports.randomBytes = randomBytes;
function unishortString(bytes) {
    let string = '';
    for (const byte of bytes)
        string += String.fromCharCode(byte);
    return string;
}
exports.unishortString = unishortString;
function unishortBytes(string) {
    const bytes = [];
    for (let index = 0; index < string.length; index++)
        bytes.push(string.charCodeAt(index));
    return Uint8Array.from(bytes);
}
exports.unishortBytes = unishortBytes;
function addPadding(bytes) {
    const missingLength = 16 - bytes.length % 16;
    const padding = new Uint8Array(missingLength);
    padding[0] = missingLength;
    return Uint8Array.from([...padding, ...bytes]);
}
exports.addPadding = addPadding;
function removePadding(bytes) {
    const missingLength = bytes[0];
    return bytes.slice(missingLength);
}
exports.removePadding = removePadding;
